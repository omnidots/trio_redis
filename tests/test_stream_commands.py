import pytest
import trio


async def test_write_and_read_from_stream_with_groups(redis):
    group = 'group_a'
    streams = ('x', 'y', 'z')

    # Format:
    #
    #     [
    #       [<stream key>, [
    #           <message fields>,
    #           …
    #       ]],
    #       …
    #     ]
    #
    # `xreadgroup`'s reply has the same format, except
    # `<message fields>` is wrapped in a tuple together with the
    # message ID, e.g. `(<message id>, <message fields>)`.
    expected_result = [
        [b'x', [
            {b'a': b'1', b'f': b'2'},
            {b'b': b'1', b'g': b'2'},
        ]],
        [b'y', [
            {b'c': b'1', b'h': b'2'},
            {b'd': b'1.5', b'i': b'2'},
        ]],
    ]

    # Create group for every stream.
    for c in streams:
        assert await redis.xgroup_create(c, group, mkstream=True)

    # Add messages to stream.
    for stream, messages in expected_result:
        for message in messages:
            await redis.xadd(stream, message)

    # Read messages from all streams.
    actual_result = await redis.xreadgroup(
        group,
        'consumer_1',
        {s: '>' for s in streams},
    )

    # Loop over actual and epected results. The message IDs in the
    # actual result are not checked, because they are generated by
    # Redis.
    for actual, expected in zip(actual_result, expected_result):
        e_key, e_msgs = expected
        a_key, a_msgs = actual

        # Check if we're comparing message from the same stream.
        assert a_key == e_key

        # Compare message fields, skip message ID.
        for a_msg, e_msg in zip(a_msgs, e_msgs):
            assert a_msg[1] == e_msg

    # Acknowledge messages.
    for key, messages in actual_result:
        result = await redis.xack(key, 'group_a', *[id for id, _ in messages])
        assert result == 2


@pytest.mark.parametrize('extra_kwargs', (
    {'count': 'bleps'},
    {'count': 0},
    {'count': -1},
    {'block': 'bleps'},
    {'block': -1},
    {'streams': ['x', '>']},
    {'streams': {}},
))
async def test_xreadgroup_invalid_arguments(redis, extra_kwargs):
    kwargs = {'streams': {'x': '>'}, **extra_kwargs}
    assert await redis.xgroup_create('x', 'group_a', mkstream=True)
    with pytest.raises(ValueError):
        await redis.xreadgroup('group_a', 'consumer_1', **kwargs)


async def test_xadd(redis):
    await redis.xadd('x', {'foo': 'bar'})
    result = await redis.xlen('x')
    assert result == 1

    # Explicit message id.
    message_id = b'9999999999999999999-0'
    assert message_id == await redis.xadd('x', {'foo': 'bar'}, id=message_id)

    # With maxlen.
    await redis.xadd('x', {'foo': 'bar'}, maxlen=2, approximate=False)
    result = await redis.xlen('x')
    assert result == 2


async def test_xadd_with_approximate_maxlen(redis):
    for n in range(200):
        await redis.xadd('x', {'a': str(n)}, maxlen=10, approximate=True)

    result = await redis.xlen('x')
    assert 10 <= result <= 100


@pytest.mark.parametrize('extra_kwargs', (
    {'maxlen': 'bleps'},
    {'maxlen': 0},
    {'maxlen': -1},
    {'fields': {}},
    {'fields': ['a', 1]},
))
async def test_xadd_invalid_arguments(redis, extra_kwargs):
    kwargs = {'fields': {'a': 1}, **extra_kwargs}
    with pytest.raises(ValueError):
        await redis.xadd('x', **kwargs)


async def test_xlen(redis):
    result = await redis.xlen('x')
    assert result == 0
    await redis.xadd('x', {'foo': 'bar'})
    result = await redis.xlen('x')
    assert result == 1


async def test_xpending_range(redis):
    key = 'x'
    group = 'group_a'

    # XPENDING expects an existing stream and group.
    await redis.xgroup_create(key, group, mkstream=True)

    # Nothing on the stream yet.
    result = await redis.xpending_range(key, group, '-', '+', 10)
    assert result == []

    await redis.xadd(key, {'foo': 'bar'})

    # No unacknowledged messages on the stream.
    result = await redis.xpending_range(key, group, '-', '+', 10)
    assert result == []

    # Read message, reply is nopt important.
    await redis.xreadgroup(group, 'consumer_1', {key: '>'})

    # There's one pending message.
    result = await redis.xpending_range(key, group, '-', '+', 10)
    assert len(result) == 1


async def test_xclaim(redis):
    key = 'x'
    group = 'group_a'
    consumer_1 = 'consumer_1'
    consumer_2 = 'consumer_2'

    # Prepare: create stream and group, add a message,
    # and read and not acknowledge message.
    await redis.xgroup_create(key, group, mkstream=True)
    await redis.xadd('x', {b'foo': b'bar'})
    await redis.xreadgroup(group, consumer_1, {key: '>'})

    # Get pending message.
    result = await redis.xpending_range(key, group, '-', '+', 10)
    message_id = result[0]['message_id']

    # The message has not been idle for 1000ms or more,
    # so we can't claim it yet.
    result = await redis.xclaim(key, group, consumer_2, 1000, [message_id])
    assert result == []

    await trio.sleep(1)

    # Message has been idle long enough. Now it can be claimed
    # and acknowledged.
    result = await redis.xclaim(key, group, consumer_2, 1000, [message_id])
    assert result == [(message_id, {b'foo': b'bar'})]

    result = await redis.xack(key, group, message_id)
    assert result == 1


async def test_xpending(redis):
    key = 'x'
    group = 'group_a'
    consumer_1 = 'consumer_1'
    consumer_2 = 'consumer_2'

    # Prepare: create stream and group, add a message
    # and read and don't acknowledge message.
    await redis.xgroup_create(key, group, mkstream=True)
    await redis.xadd('x', {b'foo': b'bar'})
    await redis.xreadgroup(group, consumer_1, {key: '>'})
    await redis.xadd('x', {b'abc': b'xyz'})
    await redis.xreadgroup(group, consumer_2, {key: '>'})

    result = await redis.xpending(key, group)

    assert result[b'consumers'] == [
        {b'name': b'consumer_1', b'pending': b'1'},
        {b'name': b'consumer_2', b'pending': b'1'},
    ]
    assert result[b'pending'] == 2


async def test_xinfo_groups(redis):
    key = 'x'
    await redis.xgroup_create(key, 'group_a', mkstream=True)
    await redis.xgroup_create(key, 'group_b', mkstream=True)

    msgid = await redis.xadd(key, {b'foo': b'bar'})
    await redis.xreadgroup('group_a', 'consumer_1', {key: '>'})

    result = await redis.xinfo_groups(key)

    assert result == [
        {
            b'consumers': 1,
            b'last-delivered-id': msgid,
            b'name': b'group_a',
            b'pending': 1,
        },
        {
            b'consumers': 0,
            b'last-delivered-id': b'0-0',
            b'name': b'group_b',
            b'pending': 0,
        },
    ]


async def test_xinfo_stream(redis):
    key = 'x'
    await redis.xgroup_create(key, 'group_a', mkstream=True)
    payload = {b'foo': b'bar'}
    msgid_1 = await redis.xadd(key, payload)
    msgid_2 = await redis.xadd(key, payload)

    result = await redis.xinfo_stream(key)

    assert result == {
        b'first-entry': (msgid_1, payload),
        b'groups': 1,
        b'last-entry': (msgid_2, payload),
        b'last-generated-id': msgid_2,
        b'length': 2,
        b'radix-tree-keys': 1,
        b'radix-tree-nodes': 2,
    }


async def test_xdel(redis):
    key = 'x'
    payload_1 = {b'foo1': b'bar1'}
    payload_2 = {b'foo2': b'bar2'}
    msgid_1 = await redis.xadd(key, payload_1)
    msgid_2 = await redis.xadd(key, payload_2)

    assert await redis.xlen(key) == 2
    assert await redis.xrange(key) == [
        (msgid_1, payload_1),
        (msgid_2, payload_2),
    ]

    result = await redis.xdel(key, msgid_1)

    assert result == 1
    assert await redis.xlen(key) == 1
    assert await redis.xrange(key) == [
        (msgid_2, payload_2),
    ]


async def test_xtrim(redis):
    key = 'x'

    p = redis.pipeline()
    for n in range(100):
        p.xadd(key, {b'n': n})
    await p

    assert await redis.xlen(key) == 100

    result = await redis.xtrim(key, 50, approximate=False)

    assert result == 50
    assert await redis.xlen(key) == 50
