import pytest
import trio


async def test_write_and_read_from_stream_with_groups(redis):
    group = 'group_a'
    streams = ('x', 'y', 'z')

    # Format:
    #
    #     [
    #       [<stream key>, [
    #           <message fields>,
    #           …
    #       ]],
    #       …
    #     ]
    #
    # `xreadgroup`'s reply has the same format, except
    # `<message fields>` is wrapped in a tuple together with the
    # message ID, e.g. `(<message id>, <message fields>)`.
    expected_result = [
        [b'x', [
            {b'a': b'1', b'f': b'2'},
            {b'b': b'1', b'g': b'2'},
        ]],
        [b'y', [
            {b'c': b'1', b'h': b'2'},
            {b'd': b'1.5', b'i': b'2'},
        ]],
    ]

    # Create group for every stream.
    for c in streams:
        assert await redis.xgroup_create(c, group, mkstream=True)

    # Add messages to stream.
    for stream, messages in expected_result:
        for message in messages:
            await redis.xadd(stream, message)

    # Read messages from all streams.
    actual_result = await redis.xreadgroup(
        group,
        'consumer_1',
        {s: '>' for s in streams},
    )

    # Loop over actual and epected results. The message IDs in the
    # actual result are not checked, because they are generated by
    # Redis.
    for actual, expected in zip(actual_result, expected_result):
        e_key, e_msgs = expected
        a_key, a_msgs = actual

        # Check if we're comparing message from the same stream.
        assert a_key == e_key

        # Compare message fields, skip message ID.
        for a_msg, e_msg in zip(a_msgs, e_msgs):
            assert a_msg[1] == e_msg

    # Acknowledge messages.
    for key, messages in actual_result:
        result = await redis.xack(key, 'group_a', *[id for id, _ in messages])
        assert result == 2


@pytest.mark.parametrize('extra_kwargs', (
    {'count': 'bleps'},
    {'count': 0},
    {'count': -1},
    {'block': 'bleps'},
    {'block': -1},
    {'streams': ['x', '>']},
    {'streams': {}},
))
async def test_xreadgroup_invalid_arguments(redis, extra_kwargs):
    kwargs = {'streams': {'x': '>'}, **extra_kwargs}
    assert await redis.xgroup_create('x', 'group_a', mkstream=True)
    with pytest.raises(ValueError):
        await redis.xreadgroup('group_a', 'consumer_1', **kwargs)


async def test_xadd(redis):
    await redis.xadd('x', {'foo': 'bar'})
    result = await redis.xlen('x')
    assert result == 1

    # Explicit message id.
    message_id = b'9999999999999999999-0'
    assert message_id == await redis.xadd('x', {'foo': 'bar'}, id=message_id)

    # With maxlen.
    await redis.xadd('x', {'foo': 'bar'}, maxlen=2, approximate=False)
    result = await redis.xlen('x')
    assert result == 2


async def test_xadd_with_approximate_maxlen(redis):
    for n in range(200):
        await redis.xadd('x', {'a': str(n)}, maxlen=10, approximate=True)

    result = await redis.xlen('x')
    assert 10 <= result <= 100


@pytest.mark.parametrize('extra_kwargs', (
    {'maxlen': 'bleps'},
    {'maxlen': 0},
    {'maxlen': -1},
    {'fields': {}},
    {'fields': ['a', 1]},
))
async def test_xadd_invalid_arguments(redis, extra_kwargs):
    kwargs = {'fields': {'a': 1}, **extra_kwargs}
    with pytest.raises(ValueError):
        await redis.xadd('x', **kwargs)


async def test_xlen(redis):
    result = await redis.xlen('x')
    assert result == 0
    await redis.xadd('x', {'foo': 'bar'})
    result = await redis.xlen('x')
    assert result == 1


async def test_xpending(redis):
    key = 'x'
    group = 'group_a'

    # XPENDING expects an existing stream and group.
    await redis.xgroup_create(key, group, mkstream=True)

    # Nothing on the stream yet.
    result = await redis.xpending_range(key, group, '-', '+', 10)
    assert result == []

    await redis.xadd(key, {'foo': 'bar'})

    # No unacknowledged messages on the stream.
    result = await redis.xpending_range(key, group, '-', '+', 10)
    assert result == []

    # Read message, reply is nopt important.
    await redis.xreadgroup(group, 'consumer_1', {key: '>'})

    # There's one pending message.
    result = await redis.xpending_range(key, group, '-', '+', 10)
    assert len(result) == 1


async def test_xclaim(redis):
    key = 'x'
    group = 'group_a'
    consumer_1 = 'consumer_1'
    consumer_2 = 'consumer_2'

    # Prepare: create stream and group, add a message,
    # and read and not acknowledge message.
    await redis.xgroup_create(key, group, mkstream=True)
    await redis.xadd('x', {b'foo': b'bar'})
    await redis.xreadgroup(group, consumer_1, {key: '>'})

    # Get pending message.
    result = await redis.xpending_range(key, group, '-', '+', 10)
    message_id = result[0]['message_id']

    # The message has not been idle for 1000ms or more,
    # so we can't claim it yet.
    result = await redis.xclaim(key, group, consumer_2, 1000, [message_id])
    assert result == []

    await trio.sleep(1)

    # Message has been idle long enough. Now it can be claimed
    # and acknowledged.
    result = await redis.xclaim(key, group, consumer_2, 1000, [message_id])
    assert result == [(message_id, {b'foo': b'bar'})]

    result = await redis.xack(key, group, message_id)
    assert result == 1
